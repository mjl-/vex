package main

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/elliptic"
	cryptorand "crypto/rand"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"log"
	"math/big"
	"os"
	"strings"
	"time"

	_ "embed"

	"github.com/mjl-/sconf"
)

//go:embed vex.service
var serviceFile string

func quickstart(args []string) {
	xcheck := func(err error, msg string) {
		if err != nil {
			log.Fatalf("%s: %s", msg, err)
		}
	}

	fmt.Print("password for account (will echo): ")
	pw := make([]byte, 64)
	n, err := os.Stdin.Read(pw)
	xcheck(err, "reading password")
	pw = pw[:n]
	pw = bytes.TrimRight(pw, "\n")
	pw = bytes.TrimRight(pw, "\r")

	// Write config file.
	config.DataDir = "data"
	cf, err := os.OpenFile("vex.conf", os.O_CREATE|os.O_EXCL|os.O_WRONLY, 0660)
	xcheck(err, "creating vex.conf")
	err = sconf.WriteDocs(cf, &config)
	xcheck(err, "writing vex.conf")
	err = cf.Close()
	xcheck(err, "closing vex.conf")

	database = xdb()
	err = adduser(database, args[0], pw)
	xcheck(err, "adding user")

	host := "localhost"
	if len(args) == 2 {
		host = args[1]
	}

	// Generate key and self-signed certificate for use with TLS.
	privKey, err := ecdsa.GenerateKey(elliptic.P256(), cryptorand.Reader)
	xcheck(err, "generating ecdsa key for self-signed certificate")
	privKeyDER, err := x509.MarshalPKCS8PrivateKey(privKey)
	xcheck(err, "marshal private key to pkcs8")
	privBlock := &pem.Block{
		Type: "PRIVATE KEY",
		Headers: map[string]string{
			"Note": "ECDSA key generated by vex for self-signed certificate.",
		},
		Bytes: privKeyDER,
	}
	var privPEM bytes.Buffer
	err = pem.Encode(&privPEM, privBlock)
	xcheck(err, "pem-encoding private key")
	err = os.WriteFile(host+".ecdsakey.pkcs8.pem", privPEM.Bytes(), 0660)
	xcheck(err, "writing private key for self-signed certificate")

	// Now the certificate.
	template := &x509.Certificate{
		SerialNumber: big.NewInt(time.Now().Unix()), // Required field.
		DNSNames:     []string{host},
		NotBefore:    time.Now().Add(-time.Hour),
		NotAfter:     time.Now().Add(4 * 365 * 24 * time.Hour),
		Issuer: pkix.Name{
			Organization: []string{"vex"},
		},
		Subject: pkix.Name{
			Organization: []string{"vex"},
			CommonName:   host,
		},
	}
	certDER, err := x509.CreateCertificate(cryptorand.Reader, template, template, privKey.Public(), privKey)
	xcheck(err, "making self-signed certificate")

	pubBlock := &pem.Block{
		Type: "CERTIFICATE",
		// Comments (header) would cause failure to parse the certificate when we load the config.
		Bytes: certDER,
	}
	var crtPEM bytes.Buffer
	err = pem.Encode(&crtPEM, pubBlock)
	xcheck(err, "pem-encoding self-signed certificate")
	err = os.WriteFile(host+".crt.pem", crtPEM.Bytes(), 0660)
	xcheck(err, "writing self-signed certificate")

	path, err := os.Getwd()
	if err == nil {
		serviceFile = strings.ReplaceAll(serviceFile, "tls.", host+".")
		serviceFile = strings.ReplaceAll(serviceFile, "/home/vex", path)
	}
	err = os.WriteFile("vex.service", []byte(serviceFile), 0644)
	xcheck(err, "writing vex.service")

	fmt.Printf(`Created vex.conf, vex.service, data/vex.db with user and password, *.pem
with self-signed certificate/key for private authenticated writable endpoint.

To run locally for developing/testing:

	./vex -debug serve -authtlscert %s.crt.pem -authtlskey %s.ecdsakey.pkcs8.pem

To set up as a service:

	sudo chown -R vex data
	sudo chgrp vex . vex vex.conf *.pem
	sudo chmod 640 vex.conf *.pem
	sudo chmod 750 vex
	sudo chmod -R g+srwX data
	sudo chmod g+s .

	sudo systemctl enable $PWD/vex.service
	sudo journalctl -f -u vex &
	sudo systemctl start vex.service


Now you can push an image to the authenticated, writable endpoint:

        SSL_CERT_FILE=%s.crt.pem podman login %s:8201 # One-time login with username and password.
        SSL_CERT_FILE=%s.crt.pem podman image push yourproject:latest %s:8201/yourproject:latest

When using docker, you'll have to find a way for docker to want to communicate
with the self-signed certificate. E.g. add it to its insecure-registries.

And pull the image on the public endpoint:

        podman image pull localhost:8200/yourproject:latest

You may want to put a reverse HTTP proxy in front of the public endpoint.
And keep the private endpoint on a private network (VPN), or also on a
publicly accessible reverse HTTP proxy (but on a different host name).
`, host, host, host, host, host, host)
}
